set cut_paste_input [stack 0]
version 15.0 v1
push $cut_paste_input
Group {
 name LMT
 label "JMh blue compress"
 selected true
 xpos 180
 ypos -61
 addUserKnob {20 User}
 addUserKnob {41 useGPUIfAvailable_1 l "Use GPU if available" T BlinkScript1.useGPUIfAvailable}
 addUserKnob {7 hueCentre l "hue centre" R 0 360}
 hueCentre 288
 addUserKnob {7 hueWidth l "hue width" R 0 180}
 hueWidth 120
 addUserKnob {8 normM l "M normalisation" R 0 120}
 normM 60
 addUserKnob {7 threshold l "compression threshold"}
 addUserKnob {7 limit l "compression limit" R 1 5}
 limit 1.9
 addUserKnob {7 power l "compression power" R 1 3}
 power 1.2
 addUserKnob {4 workingSpace l "working space" M {ACEScg ACES2065-1}}
 addUserKnob {26 ""}
 addUserKnob {26 description l "" +STARTLINE T "Hue qualified colourfulness compression applied in the Hellwig JMh space"}
}
 Input {
  inputs 0
  name Input1
  xpos 102
  ypos -170
 }
 BlinkScript {
  kernelSourceFile /Users/nick/github/aces-ot-vwg-experiments/nuke/blueCompress.blink
  recompileCount 114
  KernelDescription "3 \"blueCompressKernel\" iterate pixelWise 6a0fc4c819f0c1fa64276087f0f0b451d61487f7f178e1a6da51ec283d4311e0 2 \"src\" Read Point \"dst\" Write Point 7 \"hue centre\" Float 1 AACQQw== \"hue width\" Float 1 AAAQQw== \"M normalisation\" Float 1 AABwQg== \"compression threshold\" Float 1 AAAAAA== \"compression limit\" Float 1 MzPzPw== \"compression power\" Float 1 mpmZPw== \"workingSpace\" Int 1 AAAAAA== 7 \"hueCentre\" 1 1 Default \"hueWidth\" 1 1 Default \"normM\" 1 1 Default \"threshold\" 1 1 Default \"limit\" 1 1 Default \"power\" 1 1 Default \"workingSpace\" 1 1 Default 11 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP0_ACES_to_XYZ_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_ACES_to_XYZ_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP0_ACES_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1_ACES_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"acesWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"surround\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"L_A\" Float 1 1 AAAAAA== \"Y_b\" Float 1 1 AAAAAA=="
  kernelSource "kernel blueCompressKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float hueCentre;\n    float hueWidth;\n    float normM;\n    float threshold;\n    float limit;\n    float power;\n    int workingSpace; // 0: ACEScg, 1: ACES2065-1\n\n  local:\n    float3x3 CAT_CAT16;\n    float3x3 CAT_CAT16_INVERSE;\n    float3x3 panlrcm;\n    float3x3 AP0_ACES_to_XYZ_matrix;\n    float3x3 AP1_ACES_to_XYZ_matrix;\n    float3x3 XYZ_to_AP0_ACES_matrix;\n    float3x3 XYZ_to_AP1_ACES_matrix;\n    \n    float3 acesWhite;\n    float3 surround;\n\n    float L_A;\n    float Y_b;\n\n  void define() \{\n    defineParam(hueCentre, \"hue centre\", 288.0f);\n    defineParam(hueWidth, \"hue width\", 144.0f);\n    defineParam(normM, \"M normalisation\", 60.0f);\n    defineParam(threshold, \"compression threshold\", 0.0f);\n    defineParam(limit, \"compression limit\", 1.9f);\n    defineParam(power, \"compression power\", 1.2f);\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround)\n  \{\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = XYZ_w.y / RGB_w;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = 2.0f * R_aw + G_aw + 0.05f * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = 2.0f * R_a2 + G_a2 + 0.05f * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  inline float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = XYZ_w.y / RGB_w;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = 2.0f * R_aw + G_aw + 0.05f * B_aw;\n\n    float hr = radians(h);\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  inline float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // Bump function centered on *offset*, *width* wide and *height* high\n  inline float bump(float x, float offset, float width, float height)\n  \{\n    float x_o = 2.0f * (x - offset) / width;\n    float y;\n    if (x_o < -1.0f || x_o > 1.0f)\n    \{\n      y = 0.0f;\n    \}\n    else\n    \{\n      y = 5.0 * height * pow(5.0f, -1.0f / (1.0f - x_o * x_o));\n    \}\n    x_o = 2.0f * (1.0f + x - offset) / width;\n    if (x_o >= -1.0f && x_o <= 1.0f)\n    \{\n      y = 5.0 * height * pow(5.0f, -1.0f / (1.0f - x_o * x_o));\n    \}\n    x_o = 2.0f * (x - offset - 1.0f) / width;\n    if (x_o >= -1.0f && x_o <= 1.0f)\n    \{\n      y = 5.0 * height * pow(5.0f, -1.0f / (1.0f - x_o * x_o));\n    \}\n    return y;\n  \}\n\n  void init() \{\n    float panlrcm_data\[] =\n    \{\n      2.0f, 1.0f, 0.05f,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n    \n    float AP0_to_XYZ_matrix_data\[] =\n    \{\n      0.9525523959f,  0.0000000000f,  0.0000936786f,\n      0.3439664498f,  0.7281660966f, -0.0721325464f,\n      0.0000000000f,  0.0000000000f,  1.0088251844f\n    \};\n    AP0_ACES_to_XYZ_matrix.setArray(AP0_to_XYZ_matrix_data);\n    XYZ_to_AP0_ACES_matrix = AP0_ACES_to_XYZ_matrix.invert();\n\n    float AP1_to_XYZ_matrix_data\[] =\n    \{\n      0.6624541811f,  0.1340042065f,  0.1561876870f,\n      0.2722287168f,  0.6740817658f,  0.0536895174f,\n     -0.0055746495f,  0.0040607335f,  1.0103391003f\n    \};\n    AP1_ACES_to_XYZ_matrix.setArray(AP1_to_XYZ_matrix_data);\n    XYZ_to_AP1_ACES_matrix = AP1_ACES_to_XYZ_matrix.invert();\n\n    float CAT_CAT16_matrix_data\[] =\n    \{\n      0.3662329270f,  0.5979188007f,  0.0357409422f,\n     -0.2155660470f,  1.0427613637f,  0.1722873040f,\n     -0.0020676190f,  0.0488260454f,  0.9503875570f\n    \};\n    CAT_CAT16.setArray(CAT_CAT16_matrix_data);\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    acesWhite = 100.0f * vector_dot(AP0_ACES_to_XYZ_matrix, float3(1.0f, 1.0f, 1.0f));\n    surround = float3(0.9f, 0.59f, 0.9f);\n    L_A = 100.0f;\n    Y_b = 20.0f;\n  \}\n\n  void process() \{\n    SampleType(src) input = src();\n\n//     const float ap1BlueCuspM = 60.237217f;\n\n    float3 srcRGB(input.x, input.y, input.z);\n\n    float3 srcXYZ;\n    if (workingSpace == 1)\n    \{\n      srcXYZ = vector_dot(AP0_ACES_to_XYZ_matrix, srcRGB);\n    \}\n    else\n    \{\n      srcXYZ = vector_dot(AP1_ACES_to_XYZ_matrix, srcRGB);\n    \}\n    srcXYZ *= 100.0f;\n\n    float3 srcJMh = XYZ_to_Hellwig2022_JMh(srcXYZ, acesWhite, L_A, Y_b, surround);\n\n    float norm = normM * pow(srcJMh.x / normM, 1.14f);\n    float mNorm = srcJMh.y / norm;\n    float mCompressed = norm * compressPowerP(mNorm, threshold, limit, power, 0);\n    float scale = bump(srcJMh.z / 360.0f, fmod(hueCentre, 360.0f) / 360.0f, hueWidth / 360.0f, 1.0f);\n    float mOut = (1.0f - scale) * srcJMh.y + scale * mCompressed;\n    \n    float3 dstJMh = float3(srcJMh.x, mOut, srcJMh.z);\n    float3 dstXYZ = Hellwig2022_JMh_to_XYZ(dstJMh, acesWhite, L_A, Y_b, surround);\n    dstXYZ /= 100.0f;\n\n    float3 dstRGB;\n    if (workingSpace == 1)\n    \{\n      dstRGB = vector_dot(XYZ_to_AP0_ACES_matrix, dstXYZ);\n    \}\n    else\n    \{\n      dstRGB = vector_dot(XYZ_to_AP1_ACES_matrix, dstXYZ);\n    \}\n\n    dst() = float4(dstRGB.x, dstRGB.y, dstRGB.z, input.w);\n  \}\n\};\n"
  rebuild ""
  "blueCompressKernel_hue centre" {{parent.hueCentre}}
  "blueCompressKernel_hue width" {{parent.hueWidth}}
  "blueCompressKernel_M normalisation" {{parent.normM}}
  "blueCompressKernel_compression threshold" {{parent.threshold}}
  "blueCompressKernel_compression limit" {{parent.limit}}
  "blueCompressKernel_compression power" {{parent.power}}
  blueCompressKernel_workingSpace {{parent.workingSpace}}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 102
  ypos -61
 }
 Output {
  name Output1
  xpos 102
  ypos 85
 }
end_group
